worker_processes  auto;

error_log         "/opt/bitnami/openresty/nginx/logs/error.log";
pid               "/opt/bitnami/openresty/nginx/tmp/nginx.pid";


events {
    worker_connections  1024;
}


http {
    include       mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log    "/opt/bitnami/openresty/nginx/logs/access.log" main;
    add_header    X-Frame-Options SAMEORIGIN;

    client_body_temp_path  "/opt/bitnami/openresty/nginx/tmp/client_body" 1 2;
    proxy_temp_path        "/opt/bitnami/openresty/nginx/tmp/proxy" 1 2;
    fastcgi_temp_path      "/opt/bitnami/openresty/nginx/tmp/fastcgi" 1 2;
    scgi_temp_path         "/opt/bitnami/openresty/nginx/tmp/scgi" 1 2;
    uwsgi_temp_path        "/opt/bitnami/openresty/nginx/tmp/uwsgi" 1 2;

    sendfile           on;
    tcp_nopush         on;
    tcp_nodelay        off;
    gzip               on;
    gzip_http_version  1.0;
    gzip_comp_level    2;
    gzip_proxied       any;
    gzip_types         text/plain text/css application/javascript text/xml application/xml+rss;
    keepalive_timeout  65;
    ssl_protocols      TLSv1.2 TLSv1.3;
    ssl_ciphers        HIGH:!aNULL:!MD5;
    client_max_body_size 80M;
    server_tokens off;

    include  "/opt/bitnami/openresty/nginx/conf/server_blocks/*.conf";

    lua_shared_dict jwt_cache 10m;
    lua_package_path "/etc/nginx/lua/?.lua;;";
    lua_need_request_body on;
    proxy_intercept_errors on;

    upstream auth_service {
        server 37.9.53.188;
    }

    upstream shop_service {
        server 37.9.53.150:8000;
    }

    # upstream guild_service {
    #     server guild:8000;
    # }

    upstream inventory_service {
        server 37.9.53.107;
    }

    init_by_lua_block {
        local utils = require "utils"
        local public_key = utils.read_public_key("/etc/nginx/lua/jwt_public_key.pem")
        ngx.shared.jwt_cache:set("public_key", public_key)
        ngx.log(ngx.INFO, "JWT public key loaded and cached")
    }

    server {
        listen 80;

        error_page 400 401 403 404 500 502 503 504 = @handle_error;

        access_by_lua_block {
            local jwt = require "resty.jwt"
            local cjson = require "cjson"
            local http = require "resty.http"

            local jwt_public_key = ngx.shared.jwt_cache:get("public_key")
            if not jwt_public_key then
                ngx.log(ngx.ERR, "Public key not found in shared dict")
                ngx.status = ngx.HTTP_INTERNAL_SERVER_ERROR
                ngx.say(cjson.encode({ error = "JWT public key error." }))
                ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)
            end

            local uri = ngx.var.uri
            if uri:find("^/auth") then
                return
            end

            local headers = ngx.req.get_headers()
            local access_token = headers["Authorization"]
            local refresh_token = headers["Refresh-Token"]

            if not access_token or not access_token:find("Bearer ") then
                ngx.status = ngx.HTTP_UNAUTHORIZED
                ngx.say(cjson.encode({ error = "Access token is missing or invalid." }))
                ngx.exit(ngx.HTTP_UNAUTHORIZED)
            end

            access_token = access_token:gsub("Bearer ", "")

            
            local ok, jwt_obj = pcall(jwt.verify, jwt, jwt_public_key, access_token)
                if not ok then
                    ngx.status = ngx.HTTP_UNAUTHORIZED
                    ngx.say(cjson.encode({ error = "Invalid JWT format." }))
                    ngx.exit(ngx.HTTP_UNAUTHORIZED)
                end
                if jwt_obj.verified then
                    ngx.req.set_header("X-User-ID", tostring(jwt_obj.payload.identity))
                    return
                end

            -- Проверим причину отказа
            if jwt_obj.reason == "token expired" and refresh_token then
                -- Обращаемся к /auth/refresh
                local httpc = http.new()
                local res, err = httpc:request_uri("http://37.9.53.188:80/api/v1/auth/refresh_token/", {
                    method = "POST",
                    headers = {
                        ["Content-Type"] = "application/json",
                        ["Refresh-Token"] = refresh_token
                    }
                })

                if res.status ~= 200 then
                    ngx.log(ngx.ERR, "Refresh request failed: ", err)
                    ngx.status = ngx.HTTP_UNAUTHORIZED
                    ngx.say(cjson.encode({ error = "Refresh request failed." }))
                    ngx.exit(ngx.HTTP_UNAUTHORIZED)
                end

                if res.status == 200 then
                    local data = cjson.decode(res.body)
                    local new_token = data["access_token"]

                    -- Повторить запрос с новым токеном
                    ngx.req.set_header("Authorization", new_token)
                    local ok, new_jwt = pcall(jwt.verify, jwt, jwt_public_key, new_token)
                    if not ok then
                        ngx.status = ngx.HTTP_UNAUTHORIZED
                        ngx.say(cjson.encode({ error = "Invalid JWT format." }))
                        ngx.exit(ngx.HTTP_UNAUTHORIZED)
                    end
                    if new_jwt.verified then
                        ngx.req.set_header("X-User-ID", tostring(new_jwt.payload.identity))
                        return
                    end
                end
            end

        ngx.status = ngx.HTTP_UNAUTHORIZED
        ngx.say(cjson.encode({ error = "Authentication failed." }))
        ngx.exit(ngx.HTTP_UNAUTHORIZED)

        }

        # location @handle_error {
        #     internal;

        #     set $error_code $status;
        #     set $error_message "An unexpected error occurred.";

        #     if ($error_code = 400) {
        #         set $error_message "Bad Request: The request was invalid or cannot be otherwise served.";
        #     }
        #     if ($error_code = 401) {
        #         set $error_message "Unauthorized: Authentication failed or user does not have permissions for the requested operation.";
        #     }
        #     if ($error_code = 403) {
        #         set $error_message "Forbidden: The server understood the request, but it refuses to authorize it.";
        #     }
        #     if ($error_code = 404) {
        #         set $error_message "Not Found: The requested resource could not be found.";
        #     }
        #     if ($error_code = 500) {
        #         set $error_message "Internal Server Error: The server encountered an unexpected condition.";
        #     }
        #     if ($error_code = 502) {
        #         set $error_message "Bad Gateway: The server, while acting as a gateway or proxy, received an invalid response from the upstream server.";
        #     }
        #     if ($error_code = 503) {
        #         set $error_message "Service Unavailable: The server is currently unable to handle the request.";
        #     }

        #     add_header Content-Type application/json;
        #     return $error_code '{"error": "$error_message"}';
        # }

        location /auth/ {
            proxy_pass http://auth_service/api/v1/auth/;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-Proto $scheme;
        }
        location /auth/confirm-email/ {
            proxy_pass http://auth_service/api/v1/auth/confirm-email/;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-Proto $scheme;

            proxy_intercept_errors on;

            error_page 400 404 = @handle_confirm_email_error;
        }

        location @handle_confirm_email_error {
            return 302 http://$http_referer;
        }

        location /shop/ {
            proxy_pass http://shop_service/;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        # location /guild/ {
        #     proxy_pass http://guild_service/;
        #     proxy_set_header Host $host;
        #     proxy_set_header X-Real-IP $remote_addr;
        #     proxy_set_header X-Forwarded-Proto $scheme;
        # }

        location /inventory/ {
            proxy_pass http://inventory_service/;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-Proto $scheme;
        }
    }
}
